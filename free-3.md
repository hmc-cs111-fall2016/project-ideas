# Plan Out

## The user and a language
This section describes who the project would serve and why a language might be a
good way to meet their needs.


### What's the need?
_What need is met by your idea? Who are you helping? What is that person's
experience like now? What would their experience be like if you could help 
them?_

My idea will help people organize the tasks they need to do and create a 
concrete plan of action that they can take. It helps people who struggle with 
productivity but might be overwhelmed on how to overcome it. There are many
productivity apps and task managers, but this language would allow someone
to input their tasks and randomly schedule the tasks into a daily calendar
based on the length, priority, and frequency of the task. Having this 
definite scheduling puts more pressure on the user to complete the tasks and
allow them to spend their time more efficiently.


### Why a language?
_Why is a DSL appropriate for your user(s)? How does it address the need?_

A DSL would allow the user to specify the nature of the tasks they need to
accomplish and be able to type out these tasks more efficiently. A GUI might be
easier to navigate initially, but having the user to input tasks through code
would allow them to be more specific with the conditions and parameters associated
with each task. The computer can then randomly generate an hourly schedule filled 
with the tasks and gives the user a visual output that outlines the schedule.


### Why you?
_What excites you about this idea? How did you come up with it?_

The idea excites me because I know that nearly all of my friends in college have
struggled with procrastination. I don't think people need to or should be productive
all the time, but when you really need motivation to be productive, it's nice to
have a really clear plan of action. Coming up with this action plan is difficult
and time-consuming to do on your own, so having a language to express the tasks you
need to accomplish and having a schedule computed for you could be an effective tool.
I came up with this idea after realizing how much time I spend adding things to my
task manager and then scheduling tasks in my calendar which sort of negates the
sort of productivity I'm trying to achieve.


### Domain
_Describe the project's domain in five words._

Task organization, automatic schedule generation


### Interface (syntax)
_How might the user interact with the language? What does programming look 
like? Why is this the right way to interact with the problem domain?_ 

The user would input their tasks in a simple text file. They would create
task objects that could have several parameters including predicted length,
priority, deadline, and frequency. The user could then group the tasks together
into different categories of tasks, such as homework, jobs, self-care, etc. The
idea is to have the language feel like the user is sort of writing down notes
about the things they need to do, and leave the organization and scheduling to
the computer.


### Operation (semantics)
_What might happen when a program runs? How does a program interact with the
user? What kinds of errors might occur, and how might they be communicated to
the user?_

The computer will associate a certain number to each task, and this number 
reflects the overall priority of the task. If the user specifies that a certain
task is a priority, it will automatically be associated with a lower number. Based
on the numbered order of all the tasks, the task will be inserted into a certain 
time block on a daily calendar. If the user connects a calendar app with the program,
the output will be reflected by filled in slots on the calendar. Otherwise, an excel file
will be generated with a table of each hour of the day and its associated task. 
Errors in syntax or overloading parameters could happen, and these errors would be 
communicated at compile time and hopefully highlighted in the code.


### Expressiveness
_What should be easy to do in this language? What should be possible, but
difficult? What should be impossible or very difficult?_

It should be easy to generate task schedules with this language. It would
be difficult to plan out a very specific schedule with this due to the randomness
generated by the program. Hence, it shouldn't be used like a calendar app where
the user can choose when to schedule each task. Since the output is very specific
as either an excel file or calendar data, it would be impossible to do much else 
like calculating a function or creating a song.


### Related work
_Are there any other DSLs in this domain? If not, describe how you know there
aren't and conjecture why not. If so, describe them and provide links. How well 
do they address the need? Are there any particularly admirable qualities of the
language? Are there parts of the language you think could be improved?_

There are several apps that deal with productivity and time management, but none
that act quite like a DSL. However, two of the apps I found shared particular
similarities with the DSL I want to implement. One of them was [MyLifeOrganized](http://www.mylifeorganized.net/),
which has the feature of taking tasks with certain due dates and automatically 
generating a list of action items that the user should take. It also seems to be 
compatible with many other commmonly used apps like calendar and email. However,
it seems to have too many features which may make it more difficult for the user 
to focus in on their goals. Another app I found was [135List](http://www.135list.com/), which
sort of nicely urges the user to prioritize their tasks and take on a manageable
set of goals to work towards. But both MyLifeOrganized and 135List don't have the
flexibility and quickness of just writing in a language, and I feel like my DSL
could make the experience of writing down what you need to do more fast and 
intuitive.


## The Project
This section examines whether the idea makes for a good CS 111 project.


### Suitability
_If someone were to work on this project, what percentage of their time would be
spent directly engaging in the **language** aspects of this project (e.g.,
making language design decisions), as opposed to "systems" aspects of the
project (e.g., implementing a complicated semantics that doesn't require a lot
of language design)?_

I think the language aspect would take around 60 percent of the time since it 
requires one to design a very simple syntax that the user could easily pick up.
This probably means making the language similar to plain English, but it would 
need to be organized in such a way that it is easy for the computer to parse. One
would need to specify the number of and types of parameters that can be associated 
with each task and also specify the way in which the code should be grouped and
organized from the user end. The "systems" aspects would take the rest of the time,
and most of the work would be in defining the algorithm for task prioritization and
formatting the output nicely.

### Scope
_How big an idea is this? How ambitious is this project?_

This idea seems like a reasonable size, particularly because the output is fairly
simple. The bulk of the work is in designing the language that would be used to
characterize tasks. Overall, the project is moderately ambitious, but I think it's
something that could be accomplished over the course of a semester.

### Benefits and drawbacks
_Why might this be a good idea for a project? Why might this not be a good idea 
project?_

I think it's a good idea for a project because it seems like it could be implemented
with one language and doesn't involve the use of other libraries or data bases. All 
of the information comes from the user, and the challenge is in designing the language
so that it is simple to use but still able to be parsed. On the other hand, something 
to consider more is whether a DSL would be the most effective way to implement the feature
of schedule generation, and perhaps it would be done better through a specified GUI.
