# Free project 1

## The user and a language
This section describes who the project would serve and why a language might be a
good way to meet their needs.


### What's the need?
_What need is met by your idea? Who are you helping? What is that person's
experience like now? What would their experience be like if you could help 
them?_

_My idea would help organize to do lists. Right now, people write to do 
lists by what to do first, which is not always an easy way of thinking 
about it and may cause people to forget tasks because they forgot
about a certain category in their to do list. So, another way people think of
a to do list by those broad categories. For instance, people organize cleaning
by room or homework by class. However, it's then hard to see the most 
efficient way of doing the tasks or even which tasks need to be done first._


### Why a language?
_Why is a DSL appropriate for your user(s)? How does it address the need?_

_A language allows for a broad amount of personalization, so that this can 
meet the needs of a large userbase. Additionally, hopefully the language 
would be able to give the user multiple options of a to do list. If it seems 
daunting to do certain tasks in a row,_


### Why you?
_What excites you about this idea? How did you come up with it?_

_I like that this can be a way to optimize time for a large group of people 
who do not necessarily have a background with technology. I thought of it 
because I ride horses with the Claremont Equestrian Team. On show days, we 
have to get horses ready through a multitude of tasks per horse, from grooming 
the horses to warming them up. We will often have very short, stressful 
periods followed by long period of time with almost nothing to do. By using a 
language like this one, we would be able to assign everyone tasks where they know 
about how long it will take them. Hopefully, this will eliminate the short, 
stressful periods with longer, calmer periods. This will help both the people and 
horses._


### Domain
_Describe the project's domain in five words._

_Organized, prioritized to do lists_


### Interface (syntax)
_How might the user interact with the language? What does programming look 
like? Why is this the right way to interact with the problem domain?_ 

_The user should be able to input their to do list based on categories. They
should be able to input this list and, possibly, also their schedule so that 
the user can determine when these tasks should be done._ 


### Operation (semantics)
_What might happen when a program runs? How does a program interact with the
user? What kinds of errors might occur, and how might they be communicated to
the user?_

_When the program runs, it should take the categories of the to do list and
figure out the best way to organize the tasks for the most efficient use of time.
So, there would be optimizations involved as well as an understanding of the
tasks and their priorities from the lists given by the user._


### Expressiveness
_What should be easy to do in this language? What should be possible, but
difficult? What should be impossible or very difficult?_

_It would be very easy to work with lists, doing everything from looping through
them to editing them when tasks are complete. It would be difficult to work with
variables or data structures that aren't lists. It would be impossible to control
pointers and other system level description in this language._


### Related work
_Are there any other DSLs in this domain? If not, describe how you know there
aren't and conjecture why not. If so, describe them and provide links. How well 
do they address the need? Are there any particularly admirable qualities of the
language? Are there parts of the language you think could be improved?_

_I don't think there are any DSLs currently that meet this need._


## The Project
This section examines whether the idea makes for a good CS 111 project.


### Suitability
_If someone were to work on this project, what percentage of their time would be
spent directly engaging in the **language** aspects of this project (e.g.,
making language design decisions), as opposed to "systems" aspects of the
project (e.g., implementing a complicated semantics that doesn't require a lot
of language design)?_

_Most would probably be language design decision based on the semantics
of building the language. Hopefully once the strcture of the language
is there, the other language design decisions would be implemented
based on what is appropriate for that structure. Because all of it is
so connected in hopes of delivering one product, all maintenance and
new features would have to interface well with all the old features._


### Scope
_How big an idea is this? How ambitious is this project?_

_This project has a rather large scope. Even starting with the best way to
get all the tasks one person needs to get done such that the most important
tasks are done first, the implementer needs to figure out how they want the
language to look to the user. Once that's built, it's about how to add features
to the language, which widens the scope immensly. Including multiple people
into the to do list, figuring out how to optimize time based on a
scheudle, and so many other features could be added based on what others
think would be the most useful._


### Benefits and drawbacks
_Why might this be a good idea for a project? Why might this not be a good idea 
project?_

_This may be a good project because the problem is very widespread to people who
use to do lists. Additionally, this project is very extendable. The basics of the
project would be a strong project, but there would also be a lot of space to 
enhance it if there was enough time and desire._  
_This may not be such a good project because I would be a user of this project.
From the definition of this problem, I am heavily involved with some of the ways
that it would be used. Although this may be good because I can see how it could
be used, this may be a strong drawback. Instead of going and asking people for
advice on how to make it more user friendly, I may be inclined to sit in my room
and convince myself that it's "user friendly" because I can use it and I am a user,
while it would not make sense to anyone but myself._
